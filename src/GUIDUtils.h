#pragma once

#include "LogUtils.h"

#include <cstdint>
#include <string>
#include <type_traits>

//
// TGUID Helper Class
//
// A lightweight, strongly-typed unique ID wrapper that generates GUIDs from
// short human-readable strings (e.g., "unit-1", "blue-faction", etc.).
//
// * Hashes are 64-bit unsigned integers, fast to compare, sort, and store.
// * Based on the FNV-1a hash algorithm, which is stable across runs.
// * In Debug builds: retains the original string for human-friendly logs.
// * In Release: string data is stripped for performance and size.
//
// * Collision-free for strings up to 10 characters drawn from [a–z0–9-].
//    Enforced by runtime validation in debug mode. Longer strings throw.
//    This works because total unique values (~4.8e15) << 2^64 (~1.8e19).
//
// * Typical usage:
//    struct MyType {};
//    TGUID<MyType> id("archer-1");
//    uint64_t raw = id.GetValue();

template <typename T>
class TGUID
{
public:
	explicit TGUID(std::string_view name, [[maybe_unused]] bool isAutoGenerated = false)
		: mID(Hash(name))
	{
#ifdef _DEBUG
		Validate(name, isAutoGenerated);
		mDebugString = std::string(name);
#endif
	}

	static TGUID<T> Generate()
	{
		std::string name = fmt::format("{}{}", anonIdPrefix, ++sAutoIncrement);
		constexpr bool isAutoGenerated = true;
		TGUID<T> guid(name, isAutoGenerated);
		return guid;
	}

	uint64_t GetValue() const { return mID; }

	std::string GetDebugString() const
	{
#ifdef _DEBUG
		return fmt::format("{}({})", mDebugString, mID);
#else
		return std::to_string(mID);
#endif
	}

	template <typename U>
	bool operator==(const TGUID<U>& other) const
	{
		return std::is_same_v<T, U> && (mID == other.mID);
	}

	template <typename U>
	bool operator<(const TGUID<U>& other) const
	{
		static_assert(std::is_same_v<T, U>, "Cannot compare GUIDs of different types");
		return mID < other.mID;
	}

private:
	constexpr std::string_view anonIdPrefix = "anon-";
	inline static uint64_t sAutoIncrement = 0;
	uint64_t mID = 0;

#ifdef _DEBUG
	std::string mDebugString;

	// Alphabet: [a-z0-9-] => 37 symbols
	static constexpr size_t kMaxSafeLength = 10;

	static constexpr bool IsValidChar(char c) { return (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || (c == '-'); }

	static void Validate(std::string_view name, bool isAutoGen)
	{
		if (name.empty())
		{
			LOG_CRITICAL("Generating GUID from empty string is not supported.");
			return;
		}

		if (name.size() > kMaxSafeLength)
		{
			LOG_CRITICAL("GUID string too long (max 10 characters for guaranteed uniqueness).");
			return;
		}

		if (!isAutoGen)
		{
			auto res = std::mismatch(anonIdPrefix.begin(), anonIdPrefix.end(), name.begin());

			if (res.first == anonIdPrefix.end())
			{
				LOG_CRITICAL("GUID strings starting with 'anon-' are reserved for auto-generated GUIDs. Please use a different prefix.");
				return;
			}
		}

		for (char c : name)
		{
			if (!IsValidChar(c))
			{
				LOG_CRITICAL(std::string("Invalid character in GUID string: '") + c + "'.");
				return;
			}
		}
	}
#endif

	// FNV-1a 64-bit hashing
	static constexpr uint64_t Hash(std::string_view str)
	{
		constexpr uint64_t FNV_offset_basis = 14695981039346656037ull;
		constexpr uint64_t FNV_prime = 1099511628211ull;

		uint64_t hash = FNV_offset_basis;
		for (char c : str)
		{
			hash ^= static_cast<uint8_t>(c);
			hash *= FNV_prime;
		}
		return hash;
	}
};

// Allow TGUID<T> to be used in std::unordered_map
namespace std
{
	template <typename T>
	struct hash<TGUID<T>>
	{
		std::size_t operator()(const TGUID<T>& guid) const noexcept { return std::hash<uint64_t>()(guid.GetValue()); }
	};
}
